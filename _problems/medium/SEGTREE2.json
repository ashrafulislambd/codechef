{"category_name":"medium","status":"success","problem_code":"SEGTREE2","problem_name":"Segment Tree","body":"<span class=\"solution-visible-txt\">All submissions for this problem are available.<\/span><h3> Read problems statements in <a target=\"_blank\" href=\"http:\/\/www.codechef.com\/download\/translated\/SNCKFL16\/mandarin\/SEGTREE2.pdf\">Mandarin Chinese<\/a>, <a target=\"_blank\" href=\"http:\/\/www.codechef.com\/download\/translated\/SNCKFL16\/russian\/SEGTREE2.pdf\">Russian<\/a> and <a target=\"_blank\" href=\"http:\/\/www.codechef.com\/download\/translated\/SNCKFL16\/vietnamese\/SEGTREE2.pdf\">Vietnamese<\/a> as well.<\/h3>\n\n\n<p>The segment tree is a data structure that is capable of processing different queries on the array in an efficient way.<\/p>\n\n<p>A segment tree is usually created with the following routine.<\/p>\n\n<pre><tt>createTree(left, right):\n    currentNode = new node()\n    currentNode->left = left\n    currentNode->right = right\n    currentNode->tag = 0\n    if (left < right):\n        middle = (left + right) \/ 2\n        currentNode->leftSon = createTree(left, middle)\n        currentNode->rightSon = createTree(middle + 1, right)\n    return currentNode\n<\/tt>\n<\/pre>       \n<p><\/p>\n<p>The routine is called as:<\/p>\n\t\t\n<pre><tt>    root = init(1, N)<\/tt>\n<\/pre>\n<p><\/p>\n            \n<p>Consider the following segment tree operations:<\/p>\n<pre><tt>changeSegtree(currentNode, left, right):\n   currentNode->tag = 1\n\n   if (left == currentNode->left) and (right == currentNode->right)\n       return\n\n   newRight = min(right, currentNode->leftSon->right)\n   if (left <= newRight):\n       changeSegtree(currentNode->leftSon, left, newRight)\n\n   newLeft = max(left, currentNode->rightSon->left)\n   if (newLeft <= right):\n       changeSegtree(currentNode->rightSon, newLeft, right)\n\n                \nchange(left, right):\n    changeSegtree(root, left, right)<\/tt>\n<\/pre>\n<p><\/p>\n\n<p>Finally, an in-order traversal of the tree can be done with the following routine:<\/p>\n\n<pre><tt>traverse(currentNode):\n    if (currentNode->leftSon != NULL)\n        traverse(currentNode->leftSon)\n    print currentNode->tag\n    if (currentNode->rightSon != NULL)\n        traverse(currentNode->rightSon)\n\n\ntraverse(root)<\/tt>\n<\/pre>\n<p><\/p>\n\n<p>You are given the value of <b>N<\/b>, denoting the length of the array on which the segment tree is built on (i.e. the second parameter to the init routine). You are also given <b>M<\/b> integers <b>T<sub>1<\/sub><\/b>, <b>T<sub>2<\/sub><\/b>, ..., <b>T<sub>M<\/sub><\/b>. Here, <b>M<\/b> is the number of nodes in the segment tree and you'll have calculate it by yourself.<\/p>\n\n<p>Your task is to find the minimum number of <b>non-overlapping<\/b> segments, so that after calling the <b>change<\/b> routine for each of these segments successively, on a newly created segment tree, the <b>traverse<\/b> routine will output <b>T<sub>1<\/sub><\/b>, <b>T<sub>2<\/sub><\/b>, ..., <b>T<sub>M<\/sub><\/b>, or state that such a set of segments doesn't exist.<\/p>\n\n<p>Two segments <b>(l<sub>1<\/sub>,r<sub>1<\/sub>)<\/b> and <b>(l<sub>2<\/sub>,r<sub>2<\/sub>)<\/b> are considered <b>overlapping<\/b> if there is some <b>i<\/b> such that <b>l<sub>1<\/sub> \u2264 i \u2264 r<sub>1<\/sub><\/b> and <b>l<sub>2<\/sub>\u00a0\u2264\u00a0i\u00a0\u2264\u00a0r<sub>2<\/sub><\/b>.<\/p>\n\n<h3>Input<\/h3>\n<p>The first line of the input contains an integer <b>T<\/b> denoting the number of test cases. The description of <b>T<\/b> test cases follows.<\/p>\n\n<p>The first line of each test case contains a single integer <b>N<\/b> denoting the length of segment tree range.<\/p>\n\n<p>The second line contains <b>M<\/b> space-separated integers <b>T<sub>1<\/sub><\/b>, <b>T<sub>2<\/sub><\/b>, ..., <b>T<sub>M<\/sub><\/b> denoting what the tags of the segment tree's nodes should be, in in-order traversal. Here, <b>M<\/b> is the number of nodes in the segment tree.<\/p>\n\n<h3>Output<\/h3>\n<p>For each test case, output a single line containing the minimum number of segments to modify. In case it's impossible to achieve the given configuration of tags, output <b>-1<\/b>.\n<\/p>\n\n<h3>Constraints<\/h3>\n<p>\n<ul>\n<li><b>1<\/b> \u2264 <b>T<\/b> \u2264 <b>5 \u00d7 10<sup>4<\/sup><\/b><\/li>\n<li><b>1<\/b> \u2264 <b>N<\/b> \u2264 <b>10<sup>5<\/sup><\/b><\/li>\n<li><b>1<\/b> \u2264 <b>Sum of N<\/b> \u2264 <b>5 \u00d7 10<sup>5<\/sup><\/b><\/li>\n<\/ul>\n<\/p>\n\n<h3>Example<\/h3>\n<pre><b>Input:<\/b>\n<tt>2\n2\n1 1 1\n2\n1 0 1<\/tt>\n\n<b>Output:<\/b>\n<tt>2\n-1<\/tt>\n<\/pre>\n\n<h3>Explanation<\/h3>\n<p><b>Example case 1.<\/b> We can call <b>change(1, 1)<\/b> and <b>change(2, 2)<\/b>.<\/p>\n\n<p><b>Example case 2.<\/b> There is no set of segments that would give the tree with such configuration of tags.<\/p>","languages_supported":"ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC","max_timelimit":"1","source_sizelimit":"50000","problem_author":"xcwgf666","problem_author_html_handle":"<span \n            class='rating' \n            style='display: inline-block; \n                    font-size: 10px; \n                    background: #FF7F00;\n                    padding: 0 3px; \n                    line-height: 1.3; \n                    color: white;\n                    margin-right: 2px;'>6&#9733;<\/span><span>xcwgf666<\/span>","problem_tester":null,"problem_tester_html_handle":"","date_added":"23-05-2016","tags":"<a class='problem-tag-small ' href='\/tags\/problems\/xcwgf666'>\n                    xcwgf666\n                <\/a>","user":{"username":null},"time":{"view_start_date":1468063200,"submit_start_date":1468063200,"visible_start_date":1468063200,"end_date":1735669800,"current":1493557974},"todo":false,"problem_status":"unattempted"}